<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Linked list manipulation: main.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Linked list manipulation
   </div>
   <div id="projectbrief">Linked list manipulation, inserting, removing and altering nodes, as well as using the hungarian algorithm to calculate the max sum</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('main_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">main.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">node structure for linked list  <a href="struct_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3b09f37e675bcd48a01bf22155996872" id="r_a3b09f37e675bcd48a01bf22155996872"><td class="memItemLeft" align="right" valign="top">typedef struct Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b09f37e675bcd48a01bf22155996872">Node</a></td></tr>
<tr class="memdesc:a3b09f37e675bcd48a01bf22155996872"><td class="mdescLeft">&#160;</td><td class="mdescRight">node structure for linked list  <br /></td></tr>
<tr class="separator:a3b09f37e675bcd48a01bf22155996872"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:affd6dacd3fcffe10f694c4b4e373d7ad" id="r_affd6dacd3fcffe10f694c4b4e373d7ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affd6dacd3fcffe10f694c4b4e373d7ad">ReadFile</a> (<a class="el" href="struct_node.html">Node</a> **head)</td></tr>
<tr class="memdesc:affd6dacd3fcffe10f694c4b4e373d7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads matrix data from file.  <br /></td></tr>
<tr class="separator:affd6dacd3fcffe10f694c4b4e373d7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06ce315700a9a6a32ed620f795e9359" id="r_ab06ce315700a9a6a32ed620f795e9359"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab06ce315700a9a6a32ed620f795e9359">attributeMatrixPosition</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:ab06ce315700a9a6a32ed620f795e9359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns matrix position to each node based on rows and columns.  <br /></td></tr>
<tr class="separator:ab06ce315700a9a6a32ed620f795e9359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2153cf8cf00d6be9c82f8941165237" id="r_afc2153cf8cf00d6be9c82f8941165237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc2153cf8cf00d6be9c82f8941165237">findMaxElement</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:afc2153cf8cf00d6be9c82f8941165237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the maximum element in the matrix by iterating through the linked list.  <br /></td></tr>
<tr class="separator:afc2153cf8cf00d6be9c82f8941165237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1287b2bd7b85528c6e4233b139d5618" id="r_ae1287b2bd7b85528c6e4233b139d5618"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1287b2bd7b85528c6e4233b139d5618">insertLine</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:ae1287b2bd7b85528c6e4233b139d5618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a line at the end of the matrix.  <br /></td></tr>
<tr class="separator:ae1287b2bd7b85528c6e4233b139d5618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a71fc41c9e747f848472d95259705d" id="r_aa0a71fc41c9e747f848472d95259705d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0a71fc41c9e747f848472d95259705d">insertLineofZeros</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:aa0a71fc41c9e747f848472d95259705d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a line of zeros at the end of the matrix.  <br /></td></tr>
<tr class="separator:aa0a71fc41c9e747f848472d95259705d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef9a8cff0c0a6df5b28ba7bdc793675" id="r_a9ef9a8cff0c0a6df5b28ba7bdc793675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ef9a8cff0c0a6df5b28ba7bdc793675">insertColumn</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:a9ef9a8cff0c0a6df5b28ba7bdc793675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a column at the end of the matrix.  <br /></td></tr>
<tr class="separator:a9ef9a8cff0c0a6df5b28ba7bdc793675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af1dda507d767fed3265070c85bb724" id="r_a3af1dda507d767fed3265070c85bb724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3af1dda507d767fed3265070c85bb724">insertColumnofZeros</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:a3af1dda507d767fed3265070c85bb724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a column of zeros at the end of the matrix.  <br /></td></tr>
<tr class="separator:a3af1dda507d767fed3265070c85bb724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53f3f841d53ad195c5f8e27eaca880d" id="r_ad53f3f841d53ad195c5f8e27eaca880d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad53f3f841d53ad195c5f8e27eaca880d">printList</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:ad53f3f841d53ad195c5f8e27eaca880d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix represented by the linked list.  <br /></td></tr>
<tr class="separator:ad53f3f841d53ad195c5f8e27eaca880d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff2f7f11ee580e1a34bc7bac3977a73" id="r_adff2f7f11ee580e1a34bc7bac3977a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adff2f7f11ee580e1a34bc7bac3977a73">printListReduced</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:adff2f7f11ee580e1a34bc7bac3977a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix represented by the linked list.  <br /></td></tr>
<tr class="separator:adff2f7f11ee580e1a34bc7bac3977a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab294052a5394043b41c756d0f0b68d" id="r_a0ab294052a5394043b41c756d0f0b68d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ab294052a5394043b41c756d0f0b68d">iterate</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:a0ab294052a5394043b41c756d0f0b68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates through the matrix to assign new values affected by the maximum element.  <br /></td></tr>
<tr class="separator:a0ab294052a5394043b41c756d0f0b68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05386464ecd3c8ae35a5ddb551679ca" id="r_aa05386464ecd3c8ae35a5ddb551679ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa05386464ecd3c8ae35a5ddb551679ca">rowReduce</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:aa05386464ecd3c8ae35a5ddb551679ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces each row by subtracting the minimum value in that row from each value in that row.  <br /></td></tr>
<tr class="separator:aa05386464ecd3c8ae35a5ddb551679ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac3272df93e6ea4f4384a0f2276b15d" id="r_abac3272df93e6ea4f4384a0f2276b15d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abac3272df93e6ea4f4384a0f2276b15d">columnReduce</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:abac3272df93e6ea4f4384a0f2276b15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces each column by finding the smallest number in each col and subtracting it from the in that same col.  <br /></td></tr>
<tr class="separator:abac3272df93e6ea4f4384a0f2276b15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a44d329b4e22142493ac1948a08600a" id="r_a3a44d329b4e22142493ac1948a08600a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a44d329b4e22142493ac1948a08600a">countZerosByLine</a> (<a class="el" href="struct_node.html">Node</a> *head, int position)</td></tr>
<tr class="memdesc:a3a44d329b4e22142493ac1948a08600a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of zeros in a line.  <br /></td></tr>
<tr class="separator:a3a44d329b4e22142493ac1948a08600a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe4587b960404ea23c2b569e68eb325" id="r_acbe4587b960404ea23c2b569e68eb325"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbe4587b960404ea23c2b569e68eb325">countZerosByCol</a> (<a class="el" href="struct_node.html">Node</a> *head, int position)</td></tr>
<tr class="memdesc:acbe4587b960404ea23c2b569e68eb325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of zeros in a column.  <br /></td></tr>
<tr class="separator:acbe4587b960404ea23c2b569e68eb325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83629f19229fdb48f5df068b5e30d92" id="r_aa83629f19229fdb48f5df068b5e30d92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa83629f19229fdb48f5df068b5e30d92">yesORno</a> (int *array[2], int c, int r)</td></tr>
<tr class="memdesc:aa83629f19229fdb48f5df068b5e30d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for tracking zeros in rows and columns.  <br /></td></tr>
<tr class="separator:aa83629f19229fdb48f5df068b5e30d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dd2df322325a115a51d39820b31021" id="r_a86dd2df322325a115a51d39820b31021"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86dd2df322325a115a51d39820b31021">isItInLine</a> (int crossedline[], int line)</td></tr>
<tr class="memdesc:a86dd2df322325a115a51d39820b31021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a line is already crossed.  <br /></td></tr>
<tr class="separator:a86dd2df322325a115a51d39820b31021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213a67baba86399e206621511d71b4b9" id="r_a213a67baba86399e206621511d71b4b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a213a67baba86399e206621511d71b4b9">isItInCol</a> (int crossedcol[], int col)</td></tr>
<tr class="memdesc:a213a67baba86399e206621511d71b4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a column is already crossed.  <br /></td></tr>
<tr class="separator:a213a67baba86399e206621511d71b4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2a803f66280f43f2c4d5a477b18090" id="r_a4e2a803f66280f43f2c4d5a477b18090"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e2a803f66280f43f2c4d5a477b18090">whatToCutLine</a> (<a class="el" href="struct_node.html">Node</a> *head, int line_to_cut)</td></tr>
<tr class="memdesc:a4e2a803f66280f43f2c4d5a477b18090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether to cut a line or not based on already crossed zeros.  <br /></td></tr>
<tr class="separator:a4e2a803f66280f43f2c4d5a477b18090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ec945c422cdb5f13a53f3e69680c05" id="r_a88ec945c422cdb5f13a53f3e69680c05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88ec945c422cdb5f13a53f3e69680c05">whatToCutCol</a> (<a class="el" href="struct_node.html">Node</a> *head, int col_to_cut)</td></tr>
<tr class="memdesc:a88ec945c422cdb5f13a53f3e69680c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether to cut a column or not based on already crossed zeros.  <br /></td></tr>
<tr class="separator:a88ec945c422cdb5f13a53f3e69680c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca812e6b1ede2b374c79c04240d0af28" id="r_aca812e6b1ede2b374c79c04240d0af28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca812e6b1ede2b374c79c04240d0af28">strikeYouAreOut</a> (<a class="el" href="struct_node.html">Node</a> *head, int arraycol[], int arrayline[])</td></tr>
<tr class="memdesc:aca812e6b1ede2b374c79c04240d0af28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crosses out lines and columns in the matrix based on the Hungarian algorithm.  <br /></td></tr>
<tr class="separator:aca812e6b1ede2b374c79c04240d0af28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc9a4bee0b896baa1748e8b1da62d2b" id="r_a8cc9a4bee0b896baa1748e8b1da62d2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cc9a4bee0b896baa1748e8b1da62d2b">done</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:a8cc9a4bee0b896baa1748e8b1da62d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final step of the Hungarian algorithm - calculates the maximum sum.  <br /></td></tr>
<tr class="separator:a8cc9a4bee0b896baa1748e8b1da62d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcb5ef0bf4fadf810872e1f277dc746" id="r_a3bcb5ef0bf4fadf810872e1f277dc746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bcb5ef0bf4fadf810872e1f277dc746">step1</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:a3bcb5ef0bf4fadf810872e1f277dc746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Step 1 of the Hungarian algorithm.  <br /></td></tr>
<tr class="separator:a3bcb5ef0bf4fadf810872e1f277dc746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a91b92fed22013c764a5dcd7f13f7b3" id="r_a3a91b92fed22013c764a5dcd7f13f7b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a91b92fed22013c764a5dcd7f13f7b3">step2</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:a3a91b92fed22013c764a5dcd7f13f7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Step 2 of the Hungarian algorithm.  <br /></td></tr>
<tr class="separator:a3a91b92fed22013c764a5dcd7f13f7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac4da7942d2bf77a5132e499edf1624" id="r_a1ac4da7942d2bf77a5132e499edf1624"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ac4da7942d2bf77a5132e499edf1624">step3</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:a1ac4da7942d2bf77a5132e499edf1624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Step 3 of the Hungarian algorithm.  <br /></td></tr>
<tr class="separator:a1ac4da7942d2bf77a5132e499edf1624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3131a5e50f4f22e7a14959b862ce5be3" id="r_a3131a5e50f4f22e7a14959b862ce5be3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3131a5e50f4f22e7a14959b862ce5be3">findSumMax</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:a3131a5e50f4f22e7a14959b862ce5be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the maximum sum using a variation of the Hungarian algorithm.  <br /></td></tr>
<tr class="separator:a3131a5e50f4f22e7a14959b862ce5be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad015bd6e426599de0ebb62f8fd1e4a89" id="r_ad015bd6e426599de0ebb62f8fd1e4a89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad015bd6e426599de0ebb62f8fd1e4a89">alterElement</a> (<a class="el" href="struct_node.html">Node</a> *head)</td></tr>
<tr class="memdesc:ad015bd6e426599de0ebb62f8fd1e4a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to alter a specific element in the matrix.  <br /></td></tr>
<tr class="separator:ad015bd6e426599de0ebb62f8fd1e4a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e07a2f3a71122dedbc9207514bad21" id="r_a94e07a2f3a71122dedbc9207514bad21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94e07a2f3a71122dedbc9207514bad21">removeLineOrCol</a> (<a class="el" href="struct_node.html">Node</a> **head_ref)</td></tr>
<tr class="memdesc:a94e07a2f3a71122dedbc9207514bad21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to remove a line or column from the matrix.  <br /></td></tr>
<tr class="separator:a94e07a2f3a71122dedbc9207514bad21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66f6b31b5ad750f1fe042a706a4e3d4" id="r_ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</td></tr>
<tr class="memdesc:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main function.  <br /></td></tr>
<tr class="separator:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4fe87cdb019382264fd895c19500171c" id="r_a4fe87cdb019382264fd895c19500171c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fe87cdb019382264fd895c19500171c">max_element</a></td></tr>
<tr class="separator:a4fe87cdb019382264fd895c19500171c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6365e20c1f2a47d970bccafbf9f72f" id="r_aba6365e20c1f2a47d970bccafbf9f72f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba6365e20c1f2a47d970bccafbf9f72f">min_element</a></td></tr>
<tr class="separator:aba6365e20c1f2a47d970bccafbf9f72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0328d339748890b00ceddbfa32ef4801" id="r_a0328d339748890b00ceddbfa32ef4801"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0328d339748890b00ceddbfa32ef4801">number_of_cols</a></td></tr>
<tr class="separator:a0328d339748890b00ceddbfa32ef4801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c34084509e09f78699ce6b76163e9e" id="r_ad9c34084509e09f78699ce6b76163e9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9c34084509e09f78699ce6b76163e9e">number_of_lines</a></td></tr>
<tr class="separator:ad9c34084509e09f78699ce6b76163e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed2b25d9f2f070cb0ee764aa0985308" id="r_a5ed2b25d9f2f070cb0ee764aa0985308"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ed2b25d9f2f070cb0ee764aa0985308">loop</a> = true</td></tr>
<tr class="separator:a5ed2b25d9f2f070cb0ee764aa0985308"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3b09f37e675bcd48a01bf22155996872" name="a3b09f37e675bcd48a01bf22155996872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b09f37e675bcd48a01bf22155996872">&#9670;&#160;</a></span>Node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct Node Node</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>node structure for linked list </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad015bd6e426599de0ebb62f8fd1e4a89" name="ad015bd6e426599de0ebb62f8fd1e4a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad015bd6e426599de0ebb62f8fd1e4a89">&#9670;&#160;</a></span>alterElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alterElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to alter a specific element in the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab06ce315700a9a6a32ed620f795e9359" name="ab06ce315700a9a6a32ed620f795e9359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06ce315700a9a6a32ed620f795e9359">&#9670;&#160;</a></span>attributeMatrixPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void attributeMatrixPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns matrix position to each node based on rows and columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abac3272df93e6ea4f4384a0f2276b15d" name="abac3272df93e6ea4f4384a0f2276b15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac3272df93e6ea4f4384a0f2276b15d">&#9670;&#160;</a></span>columnReduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void columnReduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces each column by finding the smallest number in each col and subtracting it from the in that same col. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbe4587b960404ea23c2b569e68eb325" name="acbe4587b960404ea23c2b569e68eb325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe4587b960404ea23c2b569e68eb325">&#9670;&#160;</a></span>countZerosByCol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int countZerosByCol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>position</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of zeros in a column. </p>
<p>function is essencial to figuring out which lines and columns have the most zeros so we can decide which to cross out</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
    <tr><td class="paramname">position</td><td>The position of the column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of zeros in the column </dd></dl>

</div>
</div>
<a id="a3a44d329b4e22142493ac1948a08600a" name="a3a44d329b4e22142493ac1948a08600a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a44d329b4e22142493ac1948a08600a">&#9670;&#160;</a></span>countZerosByLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int countZerosByLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>position</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of zeros in a line. </p>
<p>function is essencial to figuring out which lines and columns have the most zeros so we can decide which to cross out</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
    <tr><td class="paramname">position</td><td>The position of the line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of zeros in the line </dd></dl>

</div>
</div>
<a id="a8cc9a4bee0b896baa1748e8b1da62d2b" name="a8cc9a4bee0b896baa1748e8b1da62d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc9a4bee0b896baa1748e8b1da62d2b">&#9670;&#160;</a></span>done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Final step of the Hungarian algorithm - calculates the maximum sum. </p>
<p>this should calculate the sum using the original values and the marked function if a node is marked then we should get the original value and add it to the sum</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>
<p>if position is marked, check the original value and add it to the sum</p>
<p>ends the algorithm loop and gives the control back to the outer loop in the main function</p>

</div>
</div>
<a id="afc2153cf8cf00d6be9c82f8941165237" name="afc2153cf8cf00d6be9c82f8941165237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2153cf8cf00d6be9c82f8941165237">&#9670;&#160;</a></span>findMaxElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void findMaxElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the maximum element in the matrix by iterating through the linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3131a5e50f4f22e7a14959b862ce5be3" name="a3131a5e50f4f22e7a14959b862ce5be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3131a5e50f4f22e7a14959b862ce5be3">&#9670;&#160;</a></span>findSumMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void findSumMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the maximum sum using a variation of the Hungarian algorithm. </p>
<p>first checks if the matrix is squared or not and calls the respective functions to fix that after that, it row and column reduced, as well as printing the reductions to the console and at last, it triggers the algorithm loop, which will run, until the function done is triggered</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ef9a8cff0c0a6df5b28ba7bdc793675" name="a9ef9a8cff0c0a6df5b28ba7bdc793675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef9a8cff0c0a6df5b28ba7bdc793675">&#9670;&#160;</a></span>insertColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insertColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a column at the end of the matrix. </p>
<p>calls the attribute matrix position function at the end so every node has a position parameter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3af1dda507d767fed3265070c85bb724" name="a3af1dda507d767fed3265070c85bb724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af1dda507d767fed3265070c85bb724">&#9670;&#160;</a></span>insertColumnofZeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insertColumnofZeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a column of zeros at the end of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1287b2bd7b85528c6e4233b139d5618" name="ae1287b2bd7b85528c6e4233b139d5618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1287b2bd7b85528c6e4233b139d5618">&#9670;&#160;</a></span>insertLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insertLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a line at the end of the matrix. </p>
<p>transverses the list once to find the last element and then lets the user add a whole line</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0a71fc41c9e747f848472d95259705d" name="aa0a71fc41c9e747f848472d95259705d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a71fc41c9e747f848472d95259705d">&#9670;&#160;</a></span>insertLineofZeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insertLineofZeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a line of zeros at the end of the matrix. </p>
<p>this is specifically for the hungarian algorithm, as it requires the matrix to be a square matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a213a67baba86399e206621511d71b4b9" name="a213a67baba86399e206621511d71b4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213a67baba86399e206621511d71b4b9">&#9670;&#160;</a></span>isItInCol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isItInCol </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>crossedcol</em>[], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a column is already crossed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossedcol</td><td>Array to track crossed columns </td></tr>
    <tr><td class="paramname">col</td><td>The column to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the column is already crossed, otherwise false </dd></dl>

</div>
</div>
<a id="a86dd2df322325a115a51d39820b31021" name="a86dd2df322325a115a51d39820b31021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86dd2df322325a115a51d39820b31021">&#9670;&#160;</a></span>isItInLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isItInLine </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>crossedline</em>[], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a line is already crossed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossedline</td><td>Array to track crossed lines </td></tr>
    <tr><td class="paramname">line</td><td>The line to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the line is already crossed, otherwise false </dd></dl>

</div>
</div>
<a id="a0ab294052a5394043b41c756d0f0b68d" name="a0ab294052a5394043b41c756d0f0b68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab294052a5394043b41c756d0f0b68d">&#9670;&#160;</a></span>iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iterate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates through the matrix to assign new values affected by the maximum element. </p>
<p>this will iterate through the linked list in order to assigned the new variable in the struct with a new number obtained by subtracting from the max element of the matrix every other element</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae66f6b31b5ad750f1fe042a706a4e3d4" name="ae66f6b31b5ad750f1fe042a706a4e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f6b31b5ad750f1fe042a706a4e3d4">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main function. </p>

</div>
</div>
<a id="ad53f3f841d53ad195c5f8e27eaca880d" name="ad53f3f841d53ad195c5f8e27eaca880d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53f3f841d53ad195c5f8e27eaca880d">&#9670;&#160;</a></span>printList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the matrix represented by the linked list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adff2f7f11ee580e1a34bc7bac3977a73" name="adff2f7f11ee580e1a34bc7bac3977a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff2f7f11ee580e1a34bc7bac3977a73">&#9670;&#160;</a></span>printListReduced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printListReduced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the matrix represented by the linked list. </p>
<p>mostly for debug purposes, allows to print the matrix after the row and column reductions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affd6dacd3fcffe10f694c4b4e373d7ad" name="affd6dacd3fcffe10f694c4b4e373d7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd6dacd3fcffe10f694c4b4e373d7ad">&#9670;&#160;</a></span>ReadFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReadFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> **</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads matrix data from file. </p>
<p>this function reads the matrix data from a file and creates a linked list representation of the matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94e07a2f3a71122dedbc9207514bad21" name="a94e07a2f3a71122dedbc9207514bad21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e07a2f3a71122dedbc9207514bad21">&#9670;&#160;</a></span>removeLineOrCol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeLineOrCol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> **</td>          <td class="paramname"><span class="paramname"><em>head_ref</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to remove a line or column from the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head_ref</td><td>Pointer to the pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa05386464ecd3c8ae35a5ddb551679ca" name="aa05386464ecd3c8ae35a5ddb551679ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05386464ecd3c8ae35a5ddb551679ca">&#9670;&#160;</a></span>rowReduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rowReduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces each row by subtracting the minimum value in that row from each value in that row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bcb5ef0bf4fadf810872e1f277dc746" name="a3bcb5ef0bf4fadf810872e1f277dc746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bcb5ef0bf4fadf810872e1f277dc746">&#9670;&#160;</a></span>step1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void step1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Step 1 of the Hungarian algorithm. </p>
<p>first step is based on finding a zero per line/col and marking it so that we have a unique number selected in every row and col</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>
<p>this iteration serves to reset the attributes of the matrix before passing through this step again</p>
<p>this iteration selects a zero from every col/line so that it won't have more than one selected value in the same row/col</p>
<p>array_to_track_zeros, uses the iteration to keep track of the already marked zeros and to stop the program from marking a zero if there's already a marked one in the same row/col</p>

</div>
</div>
<a id="a3a91b92fed22013c764a5dcd7f13f7b3" name="a3a91b92fed22013c764a5dcd7f13f7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a91b92fed22013c764a5dcd7f13f7b3">&#9670;&#160;</a></span>step2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void step2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Step 2 of the Hungarian algorithm. </p>
<p>step 2 checks if the number of marked elements equals to the number of lines/cols indicating there's an unique number for every line/col, if not, it prompts the counting zeros per line and col functions and the strike out function so we can proceed with the algorithm</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>
<p>sets everything to 0 to prevent errors</p>

</div>
</div>
<a id="a1ac4da7942d2bf77a5132e499edf1624" name="a1ac4da7942d2bf77a5132e499edf1624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac4da7942d2bf77a5132e499edf1624">&#9670;&#160;</a></span>step3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void step3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Step 3 of the Hungarian algorithm. </p>
<p>step 3 is based on finding the minimum element that's not crossed out we then iterate through the linked list again, subtracting the min val from the uncrossed elements and adding the min val to the values that have been crossed twice</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca812e6b1ede2b374c79c04240d0af28" name="aca812e6b1ede2b374c79c04240d0af28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca812e6b1ede2b374c79c04240d0af28">&#9670;&#160;</a></span>strikeYouAreOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void strikeYouAreOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>arraycol</em>[], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>arrayline</em>[]</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crosses out lines and columns in the matrix based on the Hungarian algorithm. </p>
<p>this will use the two arrays to check which line/col has more zeros, so those can be cut out first funtion stops when the total number of zeros is equal to the amount of zeros crossed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
    <tr><td class="paramname">arraycol</td><td>Array tracking zeros by columns </td></tr>
    <tr><td class="paramname">arrayline</td><td>Array tracking zeros by rows </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88ec945c422cdb5f13a53f3e69680c05" name="a88ec945c422cdb5f13a53f3e69680c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ec945c422cdb5f13a53f3e69680c05">&#9670;&#160;</a></span>whatToCutCol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool whatToCutCol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col_to_cut</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether to cut a column or not based on already crossed zeros. </p>
<p>this serves to avoid cutting a column unnecessarily, as in, if perchance the number of zeros in a column were reduced to 0 after cutting another line or column</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
    <tr><td class="paramname">col_to_cut</td><td>The column to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if all zeros in the column are already crossed out, otherwise true </dd></dl>

</div>
</div>
<a id="a4e2a803f66280f43f2c4d5a477b18090" name="a4e2a803f66280f43f2c4d5a477b18090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2a803f66280f43f2c4d5a477b18090">&#9670;&#160;</a></span>whatToCutLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool whatToCutLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node.html">Node</a> *</td>          <td class="paramname"><span class="paramname"><em>head</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line_to_cut</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether to cut a line or not based on already crossed zeros. </p>
<p>this serves to avoid cutting a line unnecessarily, as in, if perchance the number of zeros in a line were reduced to 0 after cutting another line or column</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list </td></tr>
    <tr><td class="paramname">line_to_cut</td><td>The line to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if all zeros in the line are already crossed out, otherwise true </dd></dl>

</div>
</div>
<a id="aa83629f19229fdb48f5df068b5e30d92" name="aa83629f19229fdb48f5df068b5e30d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83629f19229fdb48f5df068b5e30d92">&#9670;&#160;</a></span>yesORno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool yesORno </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>array</em>[2], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>c</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for tracking zeros in rows and columns. </p>
<p>basically it will check if the a node containing 0 is on the same row or col of a previously marked or already crossed out zero is</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to track zeros </td></tr>
    <tr><td class="paramname">c</td><td>Column index </td></tr>
    <tr><td class="paramname">r</td><td>Row index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the element is not in the same line or col of an already marked 0, otherwise false </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5ed2b25d9f2f070cb0ee764aa0985308" name="a5ed2b25d9f2f070cb0ee764aa0985308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed2b25d9f2f070cb0ee764aa0985308">&#9670;&#160;</a></span>loop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool loop = true</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>control variable for the algorithm loop </p>

</div>
</div>
<a id="a4fe87cdb019382264fd895c19500171c" name="a4fe87cdb019382264fd895c19500171c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe87cdb019382264fd895c19500171c">&#9670;&#160;</a></span>max_element</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int max_element</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum element in the matrix </p>

</div>
</div>
<a id="aba6365e20c1f2a47d970bccafbf9f72f" name="aba6365e20c1f2a47d970bccafbf9f72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6365e20c1f2a47d970bccafbf9f72f">&#9670;&#160;</a></span>min_element</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int min_element</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minimum element in the matrix </p>

</div>
</div>
<a id="a0328d339748890b00ceddbfa32ef4801" name="a0328d339748890b00ceddbfa32ef4801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0328d339748890b00ceddbfa32ef4801">&#9670;&#160;</a></span>number_of_cols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int number_of_cols</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of columns in the matrix </p>

</div>
</div>
<a id="ad9c34084509e09f78699ce6b76163e9e" name="ad9c34084509e09f78699ce6b76163e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c34084509e09f78699ce6b76163e9e">&#9670;&#160;</a></span>number_of_lines</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int number_of_lines</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of lines in the matrix </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="main_8c.html">main.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
